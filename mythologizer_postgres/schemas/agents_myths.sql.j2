CREATE TABLE agent_myths (
    myth_id INT PRIMARY KEY REFERENCES myths(id) ON DELETE CASCADE,
    agent_id INT NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
    position INT NOT NULL CHECK (position >= 0),
    retention DOUBLE PRECISION NOT NULL CHECK (retention > 0 ),
    UNIQUE (agent_id, position)
);

CREATE INDEX agent_myths_agent_pos_idx ON agent_myths (agent_id, position);

-- Push semantics with stack behavior (LIFO - Last In, First Out)
-- New myths get the highest position (top of stack)
CREATE OR REPLACE FUNCTION push_agent_myth()
RETURNS TRIGGER AS $$
DECLARE
    max_size INT;
    cur_count INT;
    drop_id INT;
    next_position INT;
BEGIN
    -- lock the agent row for consistent capacity reads
    SELECT memory_size INTO max_size
    FROM agents
    WHERE id = NEW.agent_id
    FOR UPDATE;

    IF max_size IS NULL THEN
        RAISE EXCEPTION 'Agent % not found', NEW.agent_id;
    END IF;

    IF max_size = 0 THEN
        RAISE EXCEPTION 'Agent % has memory_size = 0. Cannot push myths', NEW.agent_id;
    END IF;

    -- a myth can belong to only one agent
    IF EXISTS (SELECT 1 FROM agent_myths WHERE myth_id = NEW.myth_id) THEN
        RAISE EXCEPTION 'Myth % already assigned to an agent', NEW.myth_id;
    END IF;

    -- Get current count without FOR UPDATE
    SELECT COUNT(*) INTO cur_count
    FROM agent_myths
    WHERE agent_id = NEW.agent_id;

    IF cur_count >= max_size THEN
        -- evict highest position myth (bottom of stack)
        SELECT myth_id INTO drop_id
        FROM agent_myths
        WHERE agent_id = NEW.agent_id
        ORDER BY position DESC
        LIMIT 1;

        DELETE FROM agent_myths
        WHERE myth_id = drop_id;
        
        -- Reorder remaining positions to be contiguous starting from 0
        UPDATE agent_myths
        SET position = new_pos
        FROM (
            SELECT myth_id, ROW_NUMBER() OVER (ORDER BY position ASC) - 1 as new_pos
            FROM agent_myths
            WHERE agent_id = NEW.agent_id
        ) reordered
        WHERE agent_myths.myth_id = reordered.myth_id;
    END IF;

    -- Shift all existing positions down by 1 to make room for new myth at position 0
    UPDATE agent_myths
    SET position = position + 1
    WHERE agent_id = NEW.agent_id;
    
    -- Assign position 0 to the new myth (top of stack)
    NEW.position := 0;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_push_agent_myth
BEFORE INSERT ON agent_myths
FOR EACH ROW
EXECUTE FUNCTION push_agent_myth();



-- Trim on memory_size change. Drops from bottom and keeps top
CREATE OR REPLACE FUNCTION trim_agent_memory()
RETURNS TRIGGER AS $$
DECLARE
    keep INT;
BEGIN
    IF NEW.memory_size < 0 THEN
        RAISE EXCEPTION 'memory_size must be >= 0';
    END IF;

    keep := NEW.memory_size;

    IF keep = 0 THEN
        DELETE FROM agent_myths WHERE agent_id = NEW.id;
        RETURN NEW;
    END IF;

    -- keep lowest positions first (top of stack). delete the rest which are the bottom entries
    DELETE FROM agent_myths am
    USING (
        SELECT myth_id
        FROM agent_myths
        WHERE agent_id = NEW.id
        ORDER BY position ASC
        OFFSET GREATEST(keep, 0)
    ) to_drop
    WHERE am.myth_id = to_drop.myth_id;
    
    -- Reorder remaining positions to be contiguous starting from 0
    UPDATE agent_myths
    SET position = new_pos
    FROM (
        SELECT myth_id, ROW_NUMBER() OVER (ORDER BY position ASC) - 1 as new_pos
        FROM agent_myths
        WHERE agent_id = NEW.id
    ) reordered
    WHERE agent_myths.myth_id = reordered.myth_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_trim_agent_memory
AFTER UPDATE OF memory_size ON agents
FOR EACH ROW
WHEN (NEW.memory_size IS DISTINCT FROM OLD.memory_size)
EXECUTE FUNCTION trim_agent_memory();

-- Manual function to recalculate positions based on retention values
CREATE OR REPLACE FUNCTION recalculate_agent_myth_positions_by_retention(agent_id_param INT)
RETURNS VOID AS $$
BEGIN
    -- Reorder positions based on retention values (highest retention = position 0)
    -- Use a two-step approach to avoid unique constraint violations
    
    -- Step 1: Assign temporary positions (offset by 10000 to avoid conflicts)
    UPDATE agent_myths
    SET position = new_pos + 10000
    FROM (
        SELECT myth_id, ROW_NUMBER() OVER (ORDER BY retention DESC, myth_id ASC) - 1 as new_pos
        FROM agent_myths
        WHERE agent_id = agent_id_param
    ) reordered
    WHERE agent_myths.myth_id = reordered.myth_id;
    
    -- Step 2: Assign final positions
    UPDATE agent_myths
    SET position = new_pos
    FROM (
        SELECT myth_id, ROW_NUMBER() OVER (ORDER BY retention DESC, myth_id ASC) - 1 as new_pos
        FROM agent_myths
        WHERE agent_id = agent_id_param
    ) reordered
    WHERE agent_myths.myth_id = reordered.myth_id;
END;
$$ LANGUAGE plpgsql;
