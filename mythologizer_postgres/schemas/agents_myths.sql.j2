CREATE TABLE agent_myths (
    myth_id INT PRIMARY KEY REFERENCES myths(id) ON DELETE CASCADE,
    agent_id INT NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
    position INT NOT NULL CHECK (position >= 0),
    retention DOUBLE PRECISION NOT NULL CHECK (retention > 0 ),
    UNIQUE (agent_id, position)
);

CREATE INDEX agent_myths_agent_pos_idx ON agent_myths (agent_id, position);

-- Push semantics with stack behavior (LIFO - Last In, First Out)
-- New myths get the highest position (top of stack)
-- NOTE: Position assignment is now handled in application code via insert_agent_myth_safe()
-- The trigger has been removed to prevent race conditions and simplify the architecture

-- No trigger function needed - position assignment is handled in application code


-- Trim on memory_size change. Drops from bottom and keeps top
CREATE OR REPLACE FUNCTION trim_agent_memory()
RETURNS TRIGGER AS $$
DECLARE
    keep INT;
BEGIN
    IF NEW.memory_size < 0 THEN
        RAISE EXCEPTION 'memory_size must be >= 0';
    END IF;

    keep := NEW.memory_size;

    IF keep = 0 THEN
        DELETE FROM agent_myths WHERE agent_id = NEW.id;
        RETURN NEW;
    END IF;

    -- keep lowest positions first (top of stack). delete the rest which are the bottom entries
    DELETE FROM agent_myths am
    USING (
        SELECT myth_id
        FROM agent_myths
        WHERE agent_id = NEW.id
        ORDER BY position ASC
        OFFSET GREATEST(keep, 0)
    ) to_drop
    WHERE am.myth_id = to_drop.myth_id;
    
    -- Reorder remaining positions to be contiguous starting from 0
    UPDATE agent_myths
    SET position = new_pos
    FROM (
        SELECT myth_id, ROW_NUMBER() OVER (ORDER BY position ASC) - 1 as new_pos
        FROM agent_myths
        WHERE agent_id = NEW.id
    ) reordered
    WHERE agent_myths.myth_id = reordered.myth_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_trim_agent_memory
AFTER UPDATE OF memory_size ON agents
FOR EACH ROW
WHEN (NEW.memory_size IS DISTINCT FROM OLD.memory_size)
EXECUTE FUNCTION trim_agent_memory();

-- Manual function to recalculate positions based on retention values
CREATE OR REPLACE FUNCTION recalculate_agent_myth_positions_by_retention(agent_id_param INT)
RETURNS VOID AS $$
BEGIN
    -- Reorder positions based on retention values (highest retention = position 0)
    -- Use a two-step approach to avoid unique constraint violations
    
    -- Step 1: Assign temporary positions (offset by 10000 to avoid conflicts)
    UPDATE agent_myths
    SET position = new_pos + 10000
    FROM (
        SELECT myth_id, ROW_NUMBER() OVER (ORDER BY retention DESC, myth_id ASC) - 1 as new_pos
        FROM agent_myths
        WHERE agent_id = agent_id_param
    ) reordered
    WHERE agent_myths.myth_id = reordered.myth_id;
    
    -- Step 2: Assign final positions
    UPDATE agent_myths
    SET position = new_pos
    FROM (
        SELECT myth_id, ROW_NUMBER() OVER (ORDER BY retention DESC, myth_id ASC) - 1 as new_pos
        FROM agent_myths
        WHERE agent_id = agent_id_param
    ) reordered
    WHERE agent_myths.myth_id = reordered.myth_id;
END;
$$ LANGUAGE plpgsql;
